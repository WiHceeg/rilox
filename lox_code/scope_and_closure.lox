var a = "global";
{
  fun showA() {
    print a;
  }

  showA();
  var a = "block";
  showA();
}

/*
上面的 Lox 代码应该打印两个 global

类似这段 Rust 代码应该打印两个 1

fn main() {
  let a = 1;
  {
    let f = || {println!("{}", a)};
    f();
    let a = 2;
    f();
  }
}

这是因为闭包会捕获其环境，也就是说，当你创建闭包 f 时，它会捕获当前环境中的 a 的值，这个值在闭包创建时就已经确定了
函数应该捕获一个冻结的环境快照，就像它存在于函数被声明的那一瞬间
*/